/*
	CodeQuest Frontend
	Written by Jonathan Verbeek - 2023
*/

import { Logger } from "./Logging";
import { Service } from "./Service";
import Interpreter from "js-interpreter";
import { VisualProgrammingService } from "./VisualProgrammingService";
import { Bindings } from "@/bindings/_bindings";
import { CodeBinding } from "@/bindings/CodeBinding";
import { SubEvent } from "sub-events";

interface ExecutionFinishedEventArgs {
    // Whether the execution ended successfully
    success: boolean;

    // If an error happened, this contains the exception
    error: Error | null;
}

// This service is responsible for executing and evaluating code, either generated by the VPL
// or typed into the text code editor
class CodeEvalService extends Service {
    public ExecutionFinishedEvent : SubEvent<ExecutionFinishedEventArgs> = new SubEvent();

    // Load a program
    public loadProgram(program : string) {
        if (program.length <= 0)
            return;

        this._program = program;

        // Create a new interpreter
        this._interpreter = new Interpreter(this._program, this.interpreterInitFunc.bind(this));
    }

    // Run the loaded program
    public run() {
        if (this._interpreter == null)
            return;

        if (!this._interpreterPaused) {
            this._timeStarted = Date.now();
        }

        // Interpreter.run() returns true if it was async and needs to execute again
        var fireEvent = false;
        try {
            if (this._interpreter.run()) {
                this._interpreterPaused = true;
            } else {
                // Not paused anymore, code execution is over now
                this.stopAndCleanup();

                fireEvent = true;
            }
        } catch (e) {
            if (typeof e == "string") {
                Logger.error(`JS Interpreter raised error: ${e}`);

                // Call event
                this.ExecutionFinishedEvent.emit({ success: false, error: null });
            } else if (e instanceof Error) {
                Logger.error(`JS Interpreter raised error: ${e.message}`);

                // Call event
                this.ExecutionFinishedEvent.emit({ success: false, error: e });
            }
        }

        // Call event if wanted
        if (fireEvent) {
            this.ExecutionFinishedEvent.emit({ success: true, error: null });
        }
    }

    // Resume interpreter execution after an async function completed
    public resumeAsyncExecution(callback : Function) {
        if (!this._interpreterPaused)
            return;

        //Logger.info("Resuming paused interpreter");
        callback();
        this.run();
    }

    // Stops the current execution
    public stopExecution() {
        if (!this._interpreterPaused)
            return;

        this.stopAndCleanup();
        this.ExecutionFinishedEvent.emit({ success: true, error: null }); // TODO: might indicate that code caused this? Maybe bubble the exception up?
    }

    // Performs cleanup after a interpreter is supposed to be stopped
    private stopAndCleanup() {
        if (!this._interpreter)
            return;

        this._interpreterPaused = false;
        var timeElapsed = (Date.now() - this._timeStarted);
        Logger.info(`Interpreter ran user code in ${(timeElapsed / 1000).toFixed(3)} seconds. Result: ${this._interpreter.value}`);
        this._interpreter = undefined;
    }

    // This function is called when initializing the interpreter to inject functionality
    // More here: https://neil.fraser.name/software/JS-Interpreter/docs.html
    private interpreterInitFunc(interpreter : Interpreter, globalObject : Object) { 
        // Go through each binding
        this._activeBindings.forEach((binding : CodeBinding, id : string) => {
            // Register with interpreter
            if (binding.async === true) {
                interpreter.setProperty(globalObject, id, interpreter.createAsyncFunction(binding.nativeFn));
            } else {
                interpreter.setProperty(globalObject, id, interpreter.createNativeFunction(binding.nativeFn));
            }

            // Call their optional setup func
            if (binding.prepareInterpreter)
                binding.prepareInterpreter(interpreter, globalObject);
        });

        // Register highlightBlock(), which is a reserved function to highlight a blockly block
        interpreter.setProperty(globalObject, "highlightBlock", interpreter.createNativeFunction((id : any) => {
            Service.get(VisualProgrammingService).highlightBlock(id);
        }));
    }

    // Registers default bindings
    public registerDefaultBindings() {
        Bindings.DEFAULT_BINDINGS.forEach(key => {
            this.registerBinding(key);
        });
    }

    // Registers a new binding by ID
    public registerBinding(id : string) {
        if (this._activeBindings.has(id))
            return;

        // Find that binding in the registry
        var binding : CodeBinding | undefined = Bindings.BINDING_REGISTRY.get(id);
        if (!binding) {
            Logger.error(`Binding "${id}" is unknown.`);
            return;
        }

        // Add to binding store
        this._activeBindings.set(id, binding);

        // Register with Blockly
        Service.get(VisualProgrammingService).registerBinding(id, binding);

        Logger.info(`Registered binding "${id}"!`);
    }

    // Unregisters a binding by ID
    public unregisterBinding(id : string) {
        if (!this._activeBindings.delete(id))
            return;

        // Unregister from Blockly
        Service.get(VisualProgrammingService).unregisterBinding(id);
        
        Logger.info(`Unregistered binding "${id}"`);
    }

    // Registers a binding set by ID
    public registerBindingSet(id : string) {
        var bindingSet = Bindings.BINDING_SETS.get(id);
        if (!bindingSet) {
            Logger.error(`Binding set "${id}" does not exist!`);
            return;
        }

        // Register
        bindingSet.forEach(binding => {
            this.registerBinding(binding);
        });

        Logger.info(`Registered binding set "${id}" with ${bindingSet?.length} bindings`);
    }

    public static makeFriendlyCode(code : string) : string {
        // Create a user-friendly version of the code that strips away everything between \*CQ-HIDE-START\* and \*CQ-HIDE-END\*
		const regex = /\/\*CQ-HIDE-START\*\/(.*)\/\*CQ-HIDE-END\*\/\n?/gm;
		return code.replace(regex, "");
    }

    private _program : string = "";
    private _interpreter : Interpreter | undefined = undefined;
    private _activeBindings : Map<string, CodeBinding> = new Map<string, CodeBinding>();
    private _interpreterPaused : boolean = false;
    private _timeStarted : number = 0;
}

export { CodeEvalService };    
export type { CodeBinding, ExecutionFinishedEventArgs };
